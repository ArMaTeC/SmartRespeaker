substitutions:
  voice_assist_idle_phase_id: '1'
  voice_assist_waiting_for_command_phase_id: '2'
  voice_assist_listening_for_command_phase_id: '3'
  voice_assist_thinking_phase_id: '4'
  voice_assist_replying_phase_id: '5'
  voice_assist_not_ready_phase_id: '10'
  voice_assist_error_phase_id: '11'
  hidden_ssid: "false"

esphome:
  name: respeaker-lite-satellite
  friendly_name: Respeaker Lite Satellite
  project:
    name: formatbce.respeaker-lite-satellite
    version: 2025.2.2
  min_version: 2025.2.0
  on_boot:
    priority: 375
    then:
      - sensor.template.publish:
          id: next_timer
          state: -1
      - script.execute: control_leds
      - delay: 10min
      - if:
          condition:
            lambda: return id(init_in_progress);
          then:
            - lambda: id(init_in_progress) = false;
            - script.execute: control_leds
  on_shutdown:
    then:
      - lambda: id(respeaker).mute_speaker();

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"
      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: "y"
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: "y"
      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: "y"
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y"

wifi:
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
  id: wifi_id
  fast_connect: true
  on_connect:
    - lambda: id(improv_ble_in_progress) = false;
    - script.execute: control_leds
  on_disconnect:
    - script.execute: control_leds
  ap:
    ssid: "Respeaker-Satellite"
    password: "lNw0AP2PKQGR"

logger:
  level: debug
  initial_level: debug
  logs:
    sensor: WARN

select:
  - platform: logger
    id: logger_select
    name: Logger Level
    disabled_by_default: true

api:
  encryption:
    key: "ZCgwWwJTbF0/EQpyOkSOl+nYyghZdE9n5tRAoEMnWDk="
  id: api_id
  actions:
    - action: start_va
      then: [voice_assistant.start]
    - action: stop_va
      then: [voice_assistant.stop]
  on_client_connected:
    - script.execute: control_leds
  on_client_disconnected:
    - script.execute: control_leds

ota:
  - platform: esphome
    id: ota_esphome
    password: !secret ota_password

i2c:
  - id: internal_i2c
    sda: GPIO5
    scl: GPIO6
    frequency: 400kHz

psram:
  mode: octal
  speed: 80MHz

globals:
  - id: init_in_progress
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: improv_ble_in_progress
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: voice_assistant_phase
    type: int
    restore_value: no
    initial_value: ${voice_assist_not_ready_phase_id}
  - id: first_active_timer
    type: voice_assistant::Timer
    restore_value: false
  - id: is_timer_active
    type: bool
    restore_value: false
  - id: factory_reset_requested
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: low_battery_alert
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: debug_mode
    type: bool
    restore_value: no
    initial_value: 'true'

switch:
  - platform: template
    id: speaker_mute_switch
    name: Speaker mute
    icon: mdi:volume-mute
    internal: true
    optimistic: true
    turn_on_action: [lambda: id(respeaker).mute_speaker();]
    turn_off_action: [lambda: id(respeaker).unmute_speaker();]
  - platform: gpio
    internal: true
    pin:
      number: GPIO4
      inverted: true
    id: mute_toggle
    on_turn_on:
      - delay: 300ms
      - switch.turn_off: mute_toggle
  - platform: template
    id: mic_mute_switch
    name: Mic mute
    icon: mdi:microphone-off
    lambda: |-
      return id(mute_state).state;
    on_turn_on:
      - light.turn_on:
          id: led_respeaker_onboard
          brightness: 50%
          red: 1
          green: 0
          blue: 0
          effect: none
      - delay: 0.5s
      - if:
          condition:
            and:
              - lambda: return !id(init_in_progress);
              - switch.is_on: mute_sound
          then:
            - script.execute:
                id: play_sound
                priority: false
                sound_file: !lambda return id(mute_switch_on_sound);
      - script.execute: control_leds
    on_turn_off:
      - light.turn_on:
          id: led_respeaker_onboard
          brightness: 50%
          red: 0
          green: 1
          blue: 0
          effect: none
      - delay: 0.5s
      - if:
          condition:
            and:
              - lambda: return !id(init_in_progress);
              - switch.is_on: mute_sound
          then:
            - script.execute:
                id: play_sound
                priority: false
                sound_file: !lambda return id(mute_switch_off_sound);
      - script.execute: control_leds
    turn_on_action: [switch.turn_on: mute_toggle]
    turn_off_action: [switch.turn_on: mute_toggle]
  - platform: template
    id: button_sound
    name: Button click sounds
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: mute_sound
    name: Mute/unmute sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      - lambda: id(stop).disable();
      - script.execute: disable_repeat
      - if:
          condition: {media_player.is_announcing:}
          then: [media_player.stop: {announcement: true}]
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 0
          duration: 1.0s
      - script.execute: control_leds
    on_turn_on:
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
      - lambda: id(stop).enable();
      - script.execute: ring_timer
      - script.execute: control_leds
      - delay: 15min
      - switch.turn_off: timer_ringing
  - platform: template
    id: is_question_response_switch
    name: "Is Question Response"
    internal: false
    optimistic: true
    restore_mode: ALWAYS_OFF
  - platform: template
    id: debug_switch
    name: "Debug Mode"
    icon: "mdi:bug"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: return id(debug_mode);
    turn_on_action:
      - lambda: id(debug_mode) = true;
    turn_off_action:
      - lambda: id(debug_mode) = false;

binary_sensor:
  - platform: gpio
    id: user_button
    pin:
      number: GPIO3
      mode: INPUT_PULLUP
      inverted: true
    name: "User button"
    on_press: [script.execute: control_leds]
    on_release:
      - script.execute: control_leds
      - if:
          condition: {lambda: return id(factory_reset_requested);}
          then: [button.press: factory_reset_button]
    on_multi_click:
      - timing:
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - if:
              condition: {lambda: return !id(init_in_progress);}
              then:
                - if:
                    condition: {switch.is_on: timer_ringing}
                    then: [switch.turn_off: timer_ringing]
                    else:
                      - if:
                          condition: {media_player.is_announcing:}
                          then: [media_player.stop: {announcement: true}]
                          else:
                            - if:
                                condition: {voice_assistant.is_running:}
                                then: [voice_assistant.stop:]
                                else:
                                  - if:
                                      condition: {media_player.is_playing:}
                                      then: [media_player.pause:]
                                      else:
                                        - if:
                                            condition:
                                              and:
                                                - switch.is_off: mic_mute_switch
                                                - not: {voice_assistant.is_running}
                                            then:
                                              - if:
                                                  condition: {switch.is_on: button_sound}
                                                  then:
                                                    - script.execute:
                                                        id: play_sound
                                                        priority: true
                                                        sound_file: !lambda return id(center_button_press_sound);
                                                    - delay: 300ms
                                              - voice_assistant.start:
      - timing:
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - if:
              condition: {lambda: return !id(init_in_progress);}
              then:
                - if:
                    condition: {switch.is_on: button_sound}
                    then:
                      - script.execute:
                          id: play_sound
                          priority: false
                          sound_file: !lambda return id(center_button_double_press_sound);
                - media_player.volume_up:
                    id: external_media_player
      - timing:
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - if:
              condition: {lambda: return !id(init_in_progress);}
              then:
                - if:
                    condition: {switch.is_on: button_sound}
                    then:
                      - script.execute:
                          id: play_sound
                          priority: false
                          sound_file: !lambda return id(center_button_triple_press_sound);
                - media_player.volume_down:
                    id: external_media_player
      - timing: [ON for at least 1s]
        then:
          - if:
              condition: {lambda: return !id(init_in_progress);}
              then:
                - if:
                    condition: {switch.is_on: button_sound}
                    then:
                      - script.execute:
                          id: play_sound
                          priority: false
                          sound_file: !lambda return id(center_button_long_press_sound);
                - light.turn_off: led_respeaker_onboard
      - timing: [ON for at least 10s]
        then:
          - light.turn_on:
              brightness: 100%
              id: led_respeaker_onboard
              effect: "Factory Reset Coming Up"
          - script.execute:
              id: play_sound
              priority: true
              sound_file: !lambda return id(factory_reset_initiated_sound);
          - wait_until: {binary_sensor.is_off: user_button}
          - if:
              condition: {lambda: return !id(factory_reset_requested);}
              then:
                - light.turn_off: led_respeaker_onboard
                - script.execute:
                    id: play_sound
                    priority: true
                    sound_file: !lambda return id(factory_reset_cancelled_sound);
      - timing: [ON for at least 22s]
        then:
          - script.execute:
              id: play_sound
              priority: true
              sound_file: !lambda return id(factory_reset_confirmed_sound);
          - light.turn_on:
              brightness: 100%
              red: 1
              green: 0
              blue: 0
              id: led_respeaker_onboard
              effect: "none"

light:
  - platform: esp32_rmt_led_strip
    id: led_respeaker_onboard
    name: LED Respeaker onboard
    disabled_by_default: true
    internal: false
    rgb_order: GRB
    pin: GPIO1
    num_leds: 1
    rmt_symbols: 192
    chipset: ws2812
    entity_category: config
    default_transition_length: 0s
    effects:
      - pulse:
          name: "Idle Breathing"
          transition_length: 2000ms
          update_interval: 50ms
          min_brightness: 0%
          max_brightness: 20%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 500ms
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Listening Pulse"
          transition_length: 1000ms
          update_interval: 1000ms
          min_brightness: 40%
          max_brightness: 60%
      - lambda:
          name: "Replying Alternate"
          update_interval: 1000ms
          lambda: |-
            static bool state = false;
            state = !state;
            auto call = id(led_respeaker_onboard).turn_on();
            if (state) {
              call.set_red(0.0);
              call.set_green(1.0);
              call.set_blue(1.0);
            } else {
              call.set_red(0.0);
              call.set_green(1.0);
              call.set_blue(0.0);
            }
            call.set_brightness(0.5);
            call.perform();
      - lambda:
          name: "Error Flash"
          update_interval: 500ms
          lambda: |-
            static bool state = false;
            state = !state;
            if (state) {
              id(led_respeaker_onboard).turn_on().set_red(1.0).set_green(0.0).set_blue(0.0).set_brightness(1.0).perform();
            } else {
              id(led_respeaker_onboard).turn_off().perform();
            }
      - pulse:
          name: "Factory Reset Coming Up"
          transition_length: 250ms
          update_interval: 250ms
          min_brightness: 0%
          max_brightness: 100%
      - lambda:
          name: "Question Response"
          update_interval: 750ms
          lambda: |-
            static int state = 0;
            state = (state + 1) % 3;
            auto call = id(led_respeaker_onboard).turn_on();
            if (state == 0) {
              call.set_red(0.0);
              call.set_green(0.0);
              call.set_blue(1.0);
            } else if (state == 1) {
              call.set_red(0.0);
              call.set_green(1.0);
              call.set_blue(0.0);
            } else {
              call.set_red(1.0);
              call.set_green(0.0);
              call.set_blue(0.0);
            }
            call.set_brightness(0.75);
            call.perform();

sensor:
  - platform: template
    id: next_timer
    name: "Next timer"
    update_interval: never
    disabled_by_default: true
    device_class: duration
    unit_of_measurement: s
    icon: "mdi:timer"
  - platform: adc
    id: battery_voltage
    pin: GPIO10
    name: "Battery Voltage"
    unit_of_measurement: "V"
    update_interval: 60s
    accuracy_decimals: 2
    filters:
      - multiply: 2
    on_value:
      - if:
          condition: 
            lambda: return x < 0.05;
          then:
            - lambda: id(low_battery_alert) = true;
            - script.execute: control_leds
          else:
            - lambda: id(low_battery_alert) = false;
            - script.execute: control_leds
  - platform: template
    id: voice_assistant_phase_sensor
    name: "Voice Assistant Phase"
    lambda: return id(voice_assistant_phase);
    update_interval: 1s
    unit_of_measurement: ""
    icon: "mdi:state-machine"

text_sensor:
  - platform: template
    id: next_timer_name
    name: "Next timer name"
    icon: "mdi:timer"
    disabled_by_default: true
  - platform: template
    id: tts_uri
    name: "TTS URI"
    disabled_by_default: true
  - platform: template
    id: last_led_trigger
    name: "Last LED Trigger"
    icon: "mdi:led-on"
    update_interval: never
  - platform: template
    id: last_response_text
    name: "Last Response Text"
    internal: true
    update_interval: never

event:
  - platform: template
    id: button_press_event
    name: "Button press"
    icon: mdi:button-pointer
    device_class: button
    event_types:
      - double_press
      - triple_press
      - long_press

script:
  - id: control_leds
    then:
      - if:
          condition:
            lambda: return id(debug_mode);
          then:
            - lambda: ESP_LOGD("control_leds", "Starting control_leds script execution");
      - lambda: |
          if (id(debug_mode)) {
            ESP_LOGD("control_leds", "voice_assistant_phase: %d", id(voice_assistant_phase));
            ESP_LOGD("control_leds", "improv_ble_in_progress: %d", id(improv_ble_in_progress));
            ESP_LOGD("control_leds", "init_in_progress: %d", id(init_in_progress));
            ESP_LOGD("control_leds", "wifi_connected: %d", id(wifi_id).is_connected());
            ESP_LOGD("control_leds", "api_connected: %d", id(api_id).is_connected());
            ESP_LOGD("control_leds", "user_button_state: %d", id(user_button).state);
            ESP_LOGD("control_leds", "low_battery_alert: %d", id(low_battery_alert));
            ESP_LOGD("control_leds", "timer_ringing: %d", id(timer_ringing).state);
            ESP_LOGD("control_leds", "media_player_state: %d", (int)id(external_media_player).state);
            ESP_LOGD("control_leds", "is_timer_active: %d", id(is_timer_active));
          }

          if (id(improv_ble_in_progress)) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: improv_ble_in_progress (Solid Blue)");
            id(control_leds_improv_ble_state).execute();
            id(last_led_trigger).publish_state("Improv BLE");
          }
          else if (id(init_in_progress)) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: init_in_progress (Pulsing Blue)");
            id(control_leds_init_state).execute();
            id(last_led_trigger).publish_state("Initializing");
          }
          else if (!id(wifi_id).is_connected() || !id(api_id).is_connected()) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: no_ha_connection (Flashing Blue)");
            id(control_leds_no_ha_connection_state).execute();
            id(last_led_trigger).publish_state("No Connection");
          }
          else if (id(user_button).state) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: user_button_pressed (Solid Cyan)");
            id(control_leds_center_button_touched).execute();
            id(last_led_trigger).publish_state("Button Pressed");
          }
          else if (id(low_battery_alert)) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: low_battery (Flashing Red)");
            id(control_leds_low_battery).execute();
            id(last_led_trigger).publish_state("Low Battery");
          }
          else if (id(timer_ringing).state) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: timer_ringing (Pulsing Yellow)");
            id(control_leds_timer_ringing).execute();
            id(last_led_trigger).publish_state("Timer Ringing");
          }
          else if (id(voice_assistant_phase) == 2) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: va_waiting_for_command (Slow Pulse Pink)");
            id(control_leds_voice_assistant_waiting_for_command_phase).execute();
            id(last_led_trigger).publish_state("Waiting for Command");
          }
          else if (id(voice_assistant_phase) == 3) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: va_listening (Green Pulse)");
            id(control_leds_voice_assistant_listening_for_command_phase).execute();
            id(last_led_trigger).publish_state("Listening");
          }
          else if (id(voice_assistant_phase) == 4) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: va_thinking (Fast Pulse Purple)");
            id(control_leds_voice_assistant_thinking_phase).execute();
            id(last_led_trigger).publish_state("Thinking");
          }
          else if (id(voice_assistant_phase) == 5) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: va_replying (Green-Cyan Alternate)");
            id(control_leds_voice_assistant_replying_phase).execute();
            id(last_led_trigger).publish_state("Speaking");
          }
          else if (id(voice_assistant_phase) == 11) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: va_error (Flashing Red)");
            id(control_leds_voice_assistant_error_phase).execute();
            id(last_led_trigger).publish_state("Error");
          }
          else if (id(voice_assistant_phase) == 10) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: va_not_ready (Solid Orange)");
            id(control_leds_voice_assistant_not_ready_phase).execute();
            id(last_led_trigger).publish_state("Not Ready");
          }
          else if (id(is_timer_active)) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: timer_ticking (Slow Pulse Yellow)");
            id(control_leds_timer_ticking).execute();
            id(last_led_trigger).publish_state("Timer Ticking");
          }
          else if (id(external_media_player).state == media_player::MediaPlayerState::MEDIA_PLAYER_STATE_PLAYING) {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: media_playing (Breathing Green)");
            id(control_leds_media_playing).execute();
            id(last_led_trigger).publish_state("Media Playing");
          }
          else {
            if (id(debug_mode)) ESP_LOGD("control_leds", "Executing: idle (LED Off)");
            id(control_leds_voice_assistant_idle_phase).execute();
            id(last_led_trigger).publish_state("Idle");
          }

          if (id(debug_mode)) {
            ESP_LOGD("control_leds", "Finished control_leds script execution");
          }
  - id: control_leds_improv_ble_state
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 0
          green: 0
          blue: 1.0
          effect: none
  - id: control_leds_init_state
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 0
          green: 0
          blue: 1.0
          effect: "Slow Pulse"
  - id: control_leds_no_ha_connection_state
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 0
          green: 0
          blue: 1.0
          effect: "Fast Pulse"
  - id: control_leds_voice_assistant_idle_phase
    then:
      - light.turn_off:
          id: led_respeaker_onboard
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 1.0
          green: 0.2
          blue: 1.0
          effect: "Slow Pulse"
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 0
          green: 1.0
          blue: 0
          effect: "Listening Pulse"
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 0.5
          green: 0
          blue: 0.5
          effect: "Fast Pulse"
  - id: control_leds_voice_assistant_replying_phase
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Replying Alternate"
  - id: control_leds_voice_assistant_error_phase
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Error Flash"
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 1.0
          green: 0.5
          blue: 0
          effect: none
  - id: control_leds_center_button_touched
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 0
          green: 1.0
          blue: 1.0
          effect: none
  - id: control_leds_timer_ringing
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 1.0
          green: 1.0
          blue: 0
          effect: "Slow Pulse"
  - id: control_leds_timer_ticking
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 1.0
          green: 1.0
          blue: 0
          effect: "Slow Pulse"
  - id: control_leds_media_playing
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 0
          green: 1.0
          blue: 0
          effect: "Idle Breathing"
  - id: control_leds_low_battery
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          red: 1.0
          green: 0
          blue: 0
          effect: "Fast Pulse"
  - id: control_leds_question_response_state
    then:
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Question Response"
  - id: ring_timer
    then:
      - script.execute: enable_repeat_one
      - script.execute:
          id: play_sound
          priority: true
          sound_file: !lambda return id(timer_finished_sound);
  - id: enable_repeat_one
    then:
      - lambda: |-
          id(external_media_player)
            ->make_call()
            .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
            .set_announcement(true)
            .perform();
          id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 500);
  - id: disable_repeat
    then:
      - lambda: |-
          id(external_media_player)
            ->make_call()
            .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
            .set_announcement(true)
            .perform();
          id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);
  - id: play_sound
    parameters:
      priority: bool
      sound_file: "audio::AudioFile*"
    then:
      - lambda: |-
          if (priority) {
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP)
              .set_announcement(true)
              .perform();
          }
          if ((id(external_media_player).state != media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING) || priority) {
            id(external_media_player)->play_file(sound_file, true, false);
          }
  - id: fetch_first_active_timer
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          auto output_timer = timers.begin()->second;
          for (auto &iterable_timer : timers) {
            if (iterable_timer.second.is_active && iterable_timer.second.seconds_left <= output_timer.seconds_left) {
              output_timer = iterable_timer.second;
            }
          }
          id(first_active_timer) = output_timer;
  - id: check_if_timers_active
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          bool output = false;
          if (timers.size() > 0) {
            for (auto &iterable_timer : timers) {
              if (iterable_timer.second.is_active) {
                output = true;
              }
            }
          }
          id(is_timer_active) = output;
  - id: activate_stop_word_if_tts_step_is_long
    then:
      - delay: 1s
      - lambda: id(stop).enable();

i2s_audio:
  - id: i2s_output
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:
      number: GPIO9
      allow_other_uses: true
  - id: i2s_input
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:
      number: GPIO9
      allow_other_uses: true

microphone:
  - platform: nabu_microphone
    i2s_din_pin: GPIO44
    adc_type: external
    pdm: false
    sample_rate: 48000
    bits_per_sample: 32bit
    i2s_mode: secondary
    i2s_audio_id: i2s_input
    channel_0:
      id: nabu_mic_va
      amplify_shift: 0
    channel_1:
      id: nabu_mic_mww
      amplify_shift: 2

speaker:
  - platform: i2s_audio
    id: i2s_audio_speaker
    sample_rate: 48000
    i2s_mode: secondary
    i2s_dout_pin: GPIO43
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    dac_type: external
    channel: stereo
    timeout: never
    buffer_duration: 100ms
    audio_dac: aic3204_dac
  - platform: mixer
    id: mixing_speaker
    output_speaker: i2s_audio_speaker
    num_channels: 2
    source_speakers:
      - id: announcement_mixing_input
        timeout: never
      - id: media_mixing_input
        timeout: never
  - platform: resampler
    id: announcement_resampling_speaker
    output_speaker: announcement_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
  - platform: resampler
    id: media_resampling_speaker
    output_speaker: media_mixing_input
    sample_rate: 48000
    bits_per_sample: 16

media_player:
  - platform: speaker
    id: external_media_player
    name: Media Player
    internal: false
    volume_increment: 0.05
    volume_min: 0.4
    volume_max: 0.85
    announcement_pipeline:
      speaker: announcement_resampling_speaker
      format: FLAC
      num_channels: 1
      sample_rate: 48000
    media_pipeline:
      speaker: media_resampling_speaker
      format: FLAC
      num_channels: 2
      sample_rate: 48000
    on_announcement:
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
    on_state:
      - if:
          condition:
            and:
              - switch.is_off: timer_ringing
              - not: {voice_assistant.is_running:}
              - not: {media_player.is_announcing:}
          then:
            - mixer_speaker.apply_ducking:
                id: media_mixing_input
                decibel_reduction: 0
                duration: 1.0s
    files:
      - id: center_button_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_press.flac
      - id: center_button_double_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_double_press.flac
      - id: center_button_triple_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_triple_press.flac
      - id: center_button_long_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_long_press.flac
      - id: factory_reset_initiated_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_initiated.mp3
      - id: factory_reset_cancelled_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_cancelled.mp3
      - id: factory_reset_confirmed_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_confirmed.mp3
      - id: mute_switch_on_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_on.flac
      - id: mute_switch_off_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_off.flac
      - id: timer_finished_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/timer_finished.flac
      - id: wake_word_triggered_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/wake_word_triggered.flac

respeaker_lite:
  id: respeaker
  reset_pin: GPIO2
  mute_state:
    internal: true
    id: mute_state
  firmware_version:
    icon: mdi:application-cog
    name: XMOS firmware version
    internal: false
    id: firmware_version
  firmware:
    url: https://github.com/formatBCE/Respeaker-Lite-ESPHome-integration/raw/refs/heads/main/respeaker_lite_i2s_dfu_firmware_48k_v1.1.0.bin
    version: "1.1.0"
    md5: 9297155d1bf3eb21a9d4db52a89ea0c6
    on_begin:
      - light.turn_on:
          brightness: 50%
          red: 0.5
          green: 0.5
          blue: 0.5
          id: led_respeaker_onboard
          effect: "Slow Pulse"
    on_end:
      - light.turn_on:
          brightness: 50%
          red: 0
          green: 1
          blue: 0
          id: led_respeaker_onboard
          effect: "Fast Pulse"
      - delay: 3s
      - light.turn_off: led_respeaker_onboard
    on_error:
      - light.turn_on:
          brightness: 50%
          red: 1
          green: 0
          blue: 0
          id: led_respeaker_onboard
          effect: "Fast Pulse"
      - delay: 3s
      - light.turn_off: led_respeaker_onboard

external_components:
  - source:
      type: git
      url: https://github.com/esphome/home-assistant-voice-pe
      ref: dev
    components: [micro_wake_word, microphone, voice_assistant]
    refresh: 0s
  - source:
      type: git
      url: https://github.com/formatBCE/home-assistant-voice-pe
      ref: 48kHz_mic_support
    components: [nabu_microphone]
    refresh: 0s
  - source:
      type: git
      url: https://github.com/formatBCE/Respeaker-Lite-ESPHome-integration
      ref: main
    components: [respeaker_lite]
    refresh: 0s

audio_dac:
  - platform: aic3204
    id: aic3204_dac
    i2c_id: internal_i2c

micro_wake_word:
  id: mww
  models:
    - model: https://github.com/kahrendt/microWakeWord/releases/download/okay_nabu_20241226.3/okay_nabu.json
      id: okay_nabu
    - model: hey_jarvis
      id: hey_jarvis
    - model: hey_mycroft
      id: hey_mycroft
    - model: https://github.com/kahrendt/microWakeWord/releases/download/stop/stop.json
      id: stop
      internal: true
  vad:
  microphone: nabu_mic_mww
  on_wake_word_detected:
    - if:
        condition: {switch.is_off: mic_mute_switch}
        then:
          - if:
              condition: {switch.is_on: timer_ringing}
              then: [switch.turn_off: timer_ringing]
              else:
                - if:
                    condition: {media_player.is_announcing:}
                    then: [media_player.stop: {announcement: true}]
                    else:
                      - if:
                          condition: {switch.is_on: wake_sound}
                          then:
                            - script.execute:
                                id: play_sound
                                priority: true
                                sound_file: !lambda return id(wake_word_triggered_sound);
                            - delay: 300ms
                      - voice_assistant.start:
                          wake_word: !lambda return wake_word;

voice_assistant:
  id: va
  microphone: nabu_mic_va
  media_player: external_media_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 0
  auto_gain: 0 dbfs
  volume_multiplier: 1
  on_client_connected:
    - if:
        condition:
          and:
            - lambda: return id(init_in_progress);
            - switch.is_on: mic_mute_switch
        then: [switch.turn_off: mic_mute_switch]
    - lambda: id(init_in_progress) = false;
    - micro_wake_word.start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_client_disconnected:
    - voice_assistant.stop:
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: control_leds
  on_error:
    - if:
        condition:
          and:
            - lambda: return !id(init_in_progress);
            - lambda: return code != "duplicate_wake_up_detected";
            - lambda: return code != "stt-no-text-recognized";
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};
          - script.execute: control_leds
  on_start:
    - mixer_speaker.apply_ducking:
        id: media_mixing_input
        decibel_reduction: 20
        duration: 0.0s
  on_listening:
    - lambda: id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_end:
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: control_leds
  on_tts_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
    - script.execute: control_leds
    - script.execute: activate_stop_word_if_tts_step_is_long
    - text_sensor.template.publish:
        id: last_response_text
        state: !lambda 'return x;'
  on_tts_end:
    - text_sensor.template.publish:
        id: tts_uri
        state: !lambda 'return x;'
    - if:
        condition:
          lambda: 'return id(last_response_text).state.back() == ''?'';'
        then:
          - switch.turn_on: is_question_response_switch
          - script.execute: control_leds_question_response_state
          - voice_assistant.start:
        else:
          - switch.turn_off: is_question_response_switch
  on_end:
    - wait_until: {not: {voice_assistant.is_running:}}
    - mixer_speaker.apply_ducking:
        id: media_mixing_input
        decibel_reduction: 0
        duration: 1.0s
    - script.stop: activate_stop_word_if_tts_step_is_long
    - if:
        condition: {switch.is_off: timer_ringing}
        then: [lambda: id(stop).disable();]
    - if:
        condition:
        - lambda: 'return id(voice_assistant_phase) == ${voice_assist_error_phase_id};'
        then: [delay: 1s]
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_timer_finished:
    - switch.turn_on: timer_ringing
    - lambda: |
        id(next_timer).publish_state(-1);
        id(next_timer_name).publish_state("-");
  on_timer_started:
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_cancelled:
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_updated:
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_tick:
    - script.execute: control_leds
    - lambda: |
        int seconds_left = id(first_active_timer).seconds_left;
        if (std::abs(seconds_left) % 5 == 0) {
          id(next_timer).publish_state(seconds_left);
        }

button:
  - platform: factory_reset
    id: factory_reset_button
    name: "Factory Reset"
    entity_category: diagnostic
    internal: true
  - platform: restart
    id: restart_button
    name: "Restart"
    entity_category: config
    disabled_by_default: true
    icon: "mdi:restart"

debug:
  update_interval: 5s
