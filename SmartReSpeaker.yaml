# Configuration settings for Respeaker Lite Satellite
substitutions:
  voice_assist_idle_phase_id: '1'
  voice_assist_waiting_for_command_phase_id: '2'
  voice_assist_listening_for_command_phase_id: '3'
  voice_assist_thinking_phase_id: '4'
  voice_assist_replying_phase_id: '5'
  voice_assist_not_ready_phase_id: '10'
  voice_assist_error_phase_id: '11'
  hidden_ssid: "false"

esphome:
  name: respeaker-lite-satellite
  friendly_name: Respeaker Lite Satellite
  project:
    name: formatbce.respeaker-lite-satellite
    version: 2025.2.2
  min_version: 2025.2.0
  on_boot:
    priority: 375
    then:
      - logger.log: "Booting ReSpeaker Lite Satellite"
      - sensor.template.publish:
          id: next_timer
          state: -1
      - script.execute: control_leds
      - delay: 10min
      - if:
          condition:
            lambda: return id(init_in_progress);
          then:
            - logger.log: "Initialization completed after 10min delay"
            - lambda: id(init_in_progress) = false;
            - script.execute: control_leds
  on_shutdown:
    then:
      - logger.log: "Shutting down - Muting speaker"
      - lambda: id(respeaker).mute_speaker();

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"
      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: "y"
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: "y"
      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: "y"
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y"

wifi:
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
  id: wifi_id
  fast_connect: true
  on_connect:
    - logger.log: "Wi-Fi connected"
    - lambda: id(improv_ble_in_progress) = false;
    - script.execute: control_leds
  on_disconnect:
    - logger.log: "Wi-Fi disconnected"
    - script.execute: control_leds
  ap:
    ssid: "Respeaker-Satellite"
    password: "lNw0AP2PKQGR"

logger:
  level: DEBUG
  initial_level: DEBUG
  logs:
    sensor: WARN
    micro_wake_word: DEBUG
    voice_assistant: DEBUG
    binary_sensor: DEBUG
    script: DEBUG
    light: DEBUG
    media_player: DEBUG
    switch: DEBUG
    respeaker_lite: DEBUG
    i2s_audio: DEBUG
    wifi: DEBUG
    api: DEBUG

select:
  - platform: logger
    id: logger_select
    name: Logger Level
    disabled_by_default: true

api:
  encryption:
    key: "ZCgwWwJTbF0/EQpyOkSOl+nYyghZdE9n5tRAoEMnWDk="
  id: api_id
  actions:
    - action: start_va
      then: 
        - logger.log: "API action: Starting voice assistant"
        - voice_assistant.start:
    - action: stop_va
      then: 
        - logger.log: "API action: Stopping voice assistant"
        - voice_assistant.stop:
  on_client_connected:
    - logger.log: "API client connected"
    - script.execute: control_leds
  on_client_disconnected:
    - logger.log: "API client disconnected"
    - script.execute: control_leds

ota:
  - platform: esphome
    id: ota_esphome
    password: !secret ota_password

i2c:
  - id: internal_i2c
    sda: GPIO5
    scl: GPIO6
    frequency: 400kHz

psram:
  mode: octal
  speed: 80MHz

globals:
  - id: init_in_progress
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: improv_ble_in_progress
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: voice_assistant_phase
    type: int
    restore_value: no
    initial_value: ${voice_assist_not_ready_phase_id}
  - id: first_active_timer
    type: voice_assistant::Timer
    restore_value: false
  - id: is_timer_active
    type: bool
    restore_value: false
  - id: factory_reset_requested
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: low_battery_alert
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: debug_mode
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: awaiting_question_response
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: led_red
    type: float
    restore_value: no
    initial_value: '1.0'
  - id: led_green
    type: float
    restore_value: no
    initial_value: '1.0'
  - id: led_blue
    type: float
    restore_value: no
    initial_value: '1.0'

switch:
  - platform: template
    id: speaker_mute_switch
    name: Speaker mute
    icon: mdi:volume-mute
    internal: true
    optimistic: true
    turn_on_action: 
      - logger.log: "Muting speaker"
      - lambda: id(respeaker).mute_speaker();
    turn_off_action: 
      - logger.log: "Unmuting speaker"
      - lambda: id(respeaker).unmute_speaker();
  - platform: gpio
    internal: true
    pin:
      number: GPIO4
      inverted: true
    id: mute_toggle
    on_turn_on:
      - logger.log: "Mute toggle ON"
      - delay: 300ms
      - switch.turn_off: mute_toggle
  - platform: template
    id: mic_mute_switch
    name: Mic mute
    icon: mdi:microphone-off
    lambda: |-
      return id(mute_state).state;
    on_turn_on:
      - logger.log: "Mic mute ON"
      - light.turn_on:
          id: led_respeaker_onboard
          brightness: 50%
          red: 1
          green: 0
          blue: 0
          effect: none
      - delay: 0.5s
      - if:
          condition:
            and:
              - lambda: return !id(init_in_progress);
              - switch.is_on: mute_sound
          then:
            - logger.log: "Playing mute ON sound"
            - script.execute:
                id: play_sound
                priority: false
                sound_file: !lambda return id(mute_switch_on_sound);
      - script.execute: control_leds
    on_turn_off:
      - logger.log: "Mic mute OFF"
      - light.turn_on:
          id: led_respeaker_onboard
          brightness: 50%
          red: 0
          green: 1
          blue: 0
          effect: none
      - delay: 0.5s
      - if:
          condition:
            and:
              - lambda: return !id(init_in_progress);
              - switch.is_on: mute_sound
          then:
            - logger.log: "Playing mute OFF sound"
            - script.execute:
                id: play_sound
                priority: false
                sound_file: !lambda return id(mute_switch_off_sound);
      - script.execute: control_leds
    turn_on_action: 
      - logger.log: "Triggering mute toggle ON"
      - switch.turn_on: mute_toggle
    turn_off_action: 
      - logger.log: "Triggering mute toggle OFF"
      - switch.turn_on: mute_toggle
  - platform: template
    id: button_sound
    name: Button click sounds
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: mute_sound
    name: Mute/unmute sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      - logger.log: "Timer ringing OFF"
      - lambda: id(stop_model).disable();
      - script.execute: disable_repeat
      - if:
          condition: {media_player.is_announcing:}
          then: 
            - logger.log: "Stopping announcement due to timer off"
            - media_player.stop: {announcement: true}
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 0
          duration: 1.0s
      - script.execute: control_leds
    on_turn_on:
      - logger.log: "Timer ringing ON"
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
      - lambda: id(stop_model).enable();
      - script.execute: ring_timer
      - script.execute: control_leds
      - delay: 15min
      - switch.turn_off: timer_ringing
  - platform: template
    id: is_question_response_switch
    name: "Is Question Response"
    internal: false
    optimistic: true
    restore_mode: ALWAYS_OFF
  - platform: template
    id: debug_switch
    name: "Debug Mode"
    icon: "mdi:bug"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: return id(debug_mode);
    turn_on_action:
      - logger.log: "Debug mode enabled"
      - lambda: id(debug_mode) = true;
    turn_off_action:
      - logger.log: "Debug mode disabled"
      - lambda: id(debug_mode) = false;

binary_sensor:
  - platform: gpio
    id: user_button
    pin:
      number: GPIO3
      inverted: true
      mode: INPUT_PULLUP
    name: "User button"
    on_press: 
      - logger.log: "User button pressed"
      - script.execute: control_leds
    on_release:
      - logger.log: "User button released"
      - script.execute: control_leds
      - if:
          condition: {lambda: return id(factory_reset_requested);}
          then: 
            - logger.log: "Factory reset requested on button release"
            - button.press: factory_reset_button
    on_multi_click:
      - timing:
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - logger.log: "Single click detected"
          - if:
              condition: {lambda: return !id(init_in_progress);}
              then:
                - if:
                    condition: {switch.is_on: timer_ringing}
                    then: 
                      - logger.log: "Stopping timer ringing"
                      - switch.turn_off: timer_ringing
                    else:
                      - if:
                          condition: {media_player.is_announcing:}
                          then: 
                            - logger.log: "Stopping announcement"
                            - media_player.stop: {announcement: true}
                          else:
                            - if:
                                condition: {voice_assistant.is_running:}
                                then: 
                                  - logger.log: "Stopping voice assistant"
                                  - voice_assistant.stop:
                                else:
                                  - if:
                                      condition: {media_player.is_playing:}
                                      then: 
                                        - logger.log: "Pausing media player"
                                        - media_player.pause:
                                      else:
                                        - if:
                                            condition:
                                              and:
                                                - switch.is_off: mic_mute_switch
                                                - not: {voice_assistant.is_running}
                                            then:
                                              - logger.log: "Starting voice assistant from button"
                                              - if:
                                                  condition: {switch.is_on: button_sound}
                                                  then:
                                                    - script.execute:
                                                        id: play_sound
                                                        priority: true
                                                        sound_file: !lambda return id(center_button_press_sound);
                                                    - delay: 300ms
                                              - voice_assistant.start:
                                                  silence_detection: True
      - timing:
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - logger.log: "Double click detected"
          - if:
              condition: {lambda: return !id(init_in_progress);}
              then:
                - if:
                    condition: {switch.is_on: button_sound}
                    then:
                      - logger.log: "Playing double press sound"
                      - script.execute:
                          id: play_sound
                          priority: false
                          sound_file: !lambda return id(center_button_double_press_sound);
                - logger.log: "Increasing media player volume"
                - media_player.volume_up:
                    id: external_media_player
      - timing:
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - logger.log: "Triple click detected"
          - if:
              condition: {lambda: return !id(init_in_progress);}
              then:
                - if:
                    condition: {switch.is_on: button_sound}
                    then:
                      - logger.log: "Playing triple press sound"
                      - script.execute:
                          id: play_sound
                          priority: false
                          sound_file: !lambda return id(center_button_triple_press_sound);
                - logger.log: "Decreasing media player volume"
                - media_player.volume_down:
                    id: external_media_player
      - timing: [ON for at least 1s]
        then:
          - logger.log: "Long press (1s) detected"
          - if:
              condition: {lambda: return !id(init_in_progress);}
              then:
                - if:
                    condition: {switch.is_on: button_sound}
                    then:
                      - logger.log: "Playing long press sound"
                      - script.execute:
                          id: play_sound
                          priority: false
                          sound_file: !lambda return id(center_button_long_press_sound);
                - light.turn_off: led_respeaker_onboard
      - timing: [ON for at least 10s]
        then:
          - logger.log: "Long press (10s) detected - Factory reset warning"
          - light.turn_on:
              brightness: 100%
              id: led_respeaker_onboard
              effect: "Factory Reset Coming Up"
          - script.execute:
              id: play_sound
              priority: true
              sound_file: !lambda return id(factory_reset_initiated_sound);
          - wait_until: {binary_sensor.is_off: user_button}
          - if:
              condition: {lambda: return !id(factory_reset_requested);}
              then:
                - logger.log: "Factory reset cancelled"
                - light.turn_off: led_respeaker_onboard
                - script.execute:
                    id: play_sound
                    priority: true
                    sound_file: !lambda return id(factory_reset_cancelled_sound);
      - timing: [ON for at least 22s]
        then:
          - logger.log: "Long press (22s) detected - Factory reset confirmed"
          - script.execute:
              id: play_sound
              priority: true
              sound_file: !lambda return id(factory_reset_confirmed_sound);
          - light.turn_on:
              brightness: 100%
              red: 1
              green: 0
              blue: 0
              id: led_respeaker_onboard
              effect: "none"
time:
  - platform: sntp
    id: esp32_time
    servers:
      - pool.ntp.org
    timezone: UTC
    on_time_sync:
      then:
        - logger.log: "Time synchronized"

light:
  - platform: esp32_rmt_led_strip
    id: led_respeaker_onboard
    name: LED Respeaker onboard
    disabled_by_default: true
    internal: false
    rgb_order: GRB
    pin: GPIO1
    num_leds: 16
    rmt_symbols: 192
    chipset: ws2812
    entity_category: config
    default_transition_length: 0s
    effects:
      - pulse:
          name: "Idle Breathing"
          transition_length: 2000ms
          update_interval: 50ms
          min_brightness: 0%
          max_brightness: 20%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 500ms
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Listening Pulse"
          transition_length: 1000ms
          update_interval: 1000ms
          min_brightness: 40%
          max_brightness: 60%
      - lambda:
          name: "Replying Alternate"
          update_interval: 1000ms
          lambda: |-
            static bool state = false;
            state = !state;
            auto call = id(led_respeaker_onboard).turn_on();
            if (state) {
              call.set_rgb(0.0, 1.0, 1.0);
            } else {
              call.set_rgb(0.0, 1.0, 0.0);
            }
            call.set_brightness(0.5);
            call.perform();
      - lambda:
          name: "Error Flash"
          update_interval: 500ms
          lambda: |-
            static bool state = false;
            state = !state;
            if (state) {
              id(led_respeaker_onboard).turn_on().set_rgb(1.0, 0.0, 0.0).set_brightness(1.0).perform();
            } else {
              id(led_respeaker_onboard).turn_off().perform();
            }
      - pulse:
          name: "Factory Reset Coming Up"
          transition_length: 250ms
          update_interval: 250ms
          min_brightness: 0%
          max_brightness: 100%
      - lambda:
          name: "Question Response"
          update_interval: 750ms
          lambda: |-
            static int state = 0;
            state = (state + 1) % 3;
            auto call = id(led_respeaker_onboard).turn_on();
            if (state == 0) {
              call.set_rgb(0.0, 0.0, 1.0);
            } else if (state == 1) {
              call.set_rgb(0.0, 1.0, 0.0);
            } else {
              call.set_rgb(1.0, 0.0, 0.0);
            }
            call.set_brightness(0.75);
            call.perform();
      - addressable_lambda:
          name: "Ring Chase"
          update_interval: 100ms
          lambda: |-
            static int position = 0;
            static float tail_brightness[16] = {0};
            for (int i = 0; i < it.size(); i++) {
              tail_brightness[i] *= 0.7;
              if (tail_brightness[i] < 0.05) tail_brightness[i] = 0;
              it[i] = ESPColor(
                (uint8_t)(id(led_red) * 255.0 * tail_brightness[i]),
                (uint8_t)(id(led_green) * 255.0 * tail_brightness[i]),
                (uint8_t)(id(led_blue) * 255.0 * tail_brightness[i])
              );
            }
            tail_brightness[position] = 1.0;
            position = (position + 1) % it.size();
      - addressable_lambda:
          name: "Rainbow Cycle"
          update_interval: 50ms
          lambda: |-
            static uint16_t hue = 0;
            hue = (hue + 1) % 360;
            for (int i = 0; i < it.size(); i++) {
              float h = fmod((float)hue + (i * 22.5), 360.0);
              float s = 1.0;
              float v = 0.5;
              float r, g, b;
              int hi = int(h / 60.0) % 6;
              float f = h / 60.0 - hi;
              float p = v * (1 - s);
              float q = v * (1 - f * s);
              float t = v * (1 - (1 - f) * s);
              switch (hi) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
              }
              it[i] = ESPColor(r * 255, g * 255, b * 255);
            }
      - addressable_lambda:
          name: "Rotating Colors"
          update_interval: 100ms
          lambda: |-
            static int position = 0;
            static const uint8_t colors[3][3] = {
              {255, 0, 0},
              {0, 255, 0},
              {0, 0, 255}
            };
            position = (position + 1) % it.size();
            for (int i = 0; i < it.size(); i++) {
              int color_idx = (i + position) % 3;
              it[i] = ESPColor(
                colors[color_idx][0],
                colors[color_idx][1],
                colors[color_idx][2]
              );
            }
      - addressable_lambda:
          name: "Clock Face"
          update_interval: 1000ms
          lambda: |-
            auto time = id(esp32_time).now();
            int hour = time.hour % 12;
            int minute = time.minute;
            int second = time.second;
            int hour_pos = hour * 16 / 12;
            int minute_pos = minute * 16 / 60;
            int second_pos = second * 16 / 60;
            it.all() = ESPColor(0, 0, 0);
            it[hour_pos] = ESPColor(255, 0, 0);
            if (hour_pos == minute_pos) {
              it[minute_pos] = ESPColor(255, 255, 0);
            } else {
              it[minute_pos] = ESPColor(0, 191, 0);
            }
            if (second_pos == hour_pos && second_pos == minute_pos) {
              it[second_pos] = ESPColor(255, 255, 255);
            } else if (second_pos == hour_pos) {
              it[second_pos] = ESPColor(255, 0, 255);
            } else if (second_pos == minute_pos) {
              it[second_pos] = ESPColor(0, 255, 255);
            } else {
              it[second_pos] = ESPColor(0, 0, 191);
            }
      - addressable_lambda:
          name: "Plasma Wave"
          update_interval: 50ms
          lambda: |-
            static float t = 0;
            t += 0.1;
            for (int i = 0; i < it.size(); i++) {
              float wave1 = sin(t + i * 0.5);
              float wave2 = sin(t * 0.7 + i * 0.3);
              float wave3 = sin(t * 0.3 + i * 0.8);
              uint8_t r = (uint8_t)((wave1 + 1) * 127);
              uint8_t g = (uint8_t)((wave2 + 1) * 127);
              uint8_t b = (uint8_t)((wave3 + 1) * 127);
              it[i] = ESPColor(r, g, b);
            }
      - addressable_lambda:
          name: "Fire Simulation"
          update_interval: 100ms
          lambda: |-
            static uint8_t heat[16] = {0};
            for (int i = 0; i < it.size(); i++) {
              heat[i] = (heat[i] > 10) ? heat[i] - rand() % 10 : 0;
            }
            heat[0] = rand() % 128 + 128;
            for (int i = it.size() - 1; i > 0; i--) {
              heat[i] = (heat[i] + heat[i-1]) / 2;
            }
            for (int i = 0; i < it.size(); i++) {
              if (heat[i] < 85) {
                it[i] = ESPColor(heat[i] * 3, 0, 0);
              } else if (heat[i] < 170) {
                it[i] = ESPColor(255, (heat[i] - 85) * 3, 0);
              } else {
                it[i] = ESPColor(255, 255, (heat[i] - 170) * 3);
              }
            }
      - addressable_lambda:
          name: "Cosmic Spiral"
          update_interval: 75ms
          lambda: |-
            static float t = 0;
            t += 0.05;
            for (int i = 0; i < it.size(); i++) {
              float angle = (i * 2 * M_PI / it.size()) + t;
              float r = (sin(angle) + 1) * 127;
              float g = (sin(angle + 2 * M_PI / 3) + 1) * 127;
              float b = (sin(angle + 4 * M_PI / 3) + 1) * 127;
              it[i] = ESPColor(r, g, b);
            }
      - addressable_lambda:
          name: "Pulse Ripple"
          update_interval: 80ms
          lambda: |-
            static float center = 0;
            center = (center + 0.2) > it.size() ? 0 : center + 0.2;
            for (int i = 0; i < it.size(); i++) {
              float dist = fabs(i - center);
              float intensity = exp(-dist * 0.5) * 255;
              it[i] = ESPColor(intensity, intensity / 2, intensity / 4);
            }
      - addressable_lambda:
          name: "Aurora Borealis"
          update_interval: 120ms
          lambda: |-
            static float t = 0;
            t += 0.03;
            for (int i = 0; i < it.size(); i++) {
              float noise = sin(t + i * 0.4) + sin(t * 1.3 + i * 0.7);
              uint8_t g = (noise + 2) * 63;
              uint8_t b = (noise + 2) * 31;
              uint8_t r = noise * 20;
              it[i] = ESPColor(r, g, b);
            }
      - addressable_lambda:
          name: "Meteor Shower"
          update_interval: 60ms
          lambda: |-
            static int pos = 0;
            static int length = 3;
            pos = (pos + 1) % (it.size() + length);
            it.all() = ESPColor(0, 0, 0);
            for (int i = pos; i > pos - length && i >= 0; i--) {
              if (i < it.size()) {
                float fade = (float)(pos - i) / length;
                it[i] = ESPColor(255 * fade, 255 * fade, 255);
              }
            }
      - addressable_lambda:
          name: "Color Vortex"
          update_interval: 70ms
          lambda: |-
            static float t = 0;
            t += 0.1;
            for (int i = 0; i < it.size(); i++) {
              float angle = i * 2 * M_PI / it.size();
              float r = (sin(t + angle) + 1) * 127;
              float g = (sin(t + angle + 2) + 1) * 127;
              float b = (sin(t + angle + 4) + 1) * 127;
              it[i] = ESPColor(r, g, b);
            }
      - addressable_lambda:
          name: "Kaleidoscope"
          update_interval: 90ms
          lambda: |-
            static float t = 0;
            t += 0.05;
            for (int i = 0; i < it.size(); i++) {
              float symmetry = sin(t + i * M_PI / 8);
              uint8_t r = (symmetry + 1) * 127;
              uint8_t g = (sin(t + i * M_PI / 4) + 1) * 127;
              uint8_t b = (cos(t + i * M_PI / 3) + 1) * 127;
              it[i] = ESPColor(r, g, b);
            }
      - addressable_lambda:
          name: "Particle Dance"
          update_interval: 40ms
          lambda: |-
            static float particles[3][2] = {{0, 0.1}, {4, -0.15}, {8, 0.2}};
            it.all() = ESPColor(0, 0, 0);
            for (int p = 0; p < 3; p++) {
              particles[p][0] += particles[p][1];
              if (particles[p][0] >= it.size()) particles[p][0] -= it.size();
              if (particles[p][0] < 0) particles[p][0] += it.size();
              int pos = (int)particles[p][0];
              it[pos] = ESPColor(255 * (p == 0), 255 * (p == 1), 255 * (p == 2));
            }
      - addressable_lambda:
          name: "Wave Interference"
          update_interval: 60ms
          lambda: |-
            static float t = 0;
            t += 0.08;
            for (int i = 0; i < it.size(); i++) {
              float wave1 = sin(t + i * 0.6);
              float wave2 = sin(t * 1.2 + i * 0.4);
              float intensity = (wave1 + wave2) * 127 + 127;
              it[i] = ESPColor(intensity, intensity * 0.7, intensity * 0.3);
            }
      - addressable_lambda:
          name: "Quantum Flux"
          update_interval: 45ms
          lambda: |-
            static float t = 0;
            t += 0.12;
            for (int i = 0; i < it.size(); i++) {
              float flux = sin(t + i * 0.9) * cos(t * 0.5 + i * 0.3);
              uint8_t r = (flux + 1) * 127;
              uint8_t g = (sin(t * 1.1 + i) + 1) * 127;
              uint8_t b = (cos(t * 0.7 + i * 1.2) + 1) * 127;
              it[i] = ESPColor(r, g, b);
            }
      - addressable_lambda:
          name: "Electric Storm"
          update_interval: 80ms
          lambda: |-
            static int strike = 0;
            strike = (rand() % 20 == 0) ? rand() % it.size() : strike;
            it.all() = ESPColor(0, 0, 20);
            if (rand() % 5 == 0) {
              it[strike] = ESPColor(255, 255, 255);
              int adj = (strike + 1) % it.size();
              it[adj] = ESPColor(200, 200, 255);
              adj = (strike - 1 + it.size()) % it.size();
              it[adj] = ESPColor(200, 200, 255);
            }
      - addressable_lambda:
          name: "Lava Flow"
          update_interval: 100ms
          lambda: |-
            static uint8_t heat[16] = {0};
            for (int i = 0; i < it.size(); i++) {
              heat[i] = (heat[i] > 5) ? heat[i] - (rand() % 5) : 0;
            }
            heat[rand() % it.size()] = 255;
            for (int i = 0; i < it.size(); i++) {
              uint8_t r = heat[i];
              uint8_t g = heat[i] / 2;
              it[i] = ESPColor(r, g, 0);
            }
      - addressable_lambda:
          name: "Digital Rain"
          update_interval: 70ms
          lambda: |-
            static int drops[3] = {0, 4, 8};
            it.all() = ESPColor(0, 20, 0);
            for (int d = 0; d < 3; d++) {
              drops[d] = (drops[d] + 1) % it.size();
              it[drops[d]] = ESPColor(0, 255, 0);
              int tail = (drops[d] - 1 + it.size()) % it.size();
              it[tail] = ESPColor(0, 127, 0);
            }
      - addressable_lambda:
          name: "Hypnotic Swirl"
          update_interval: 60ms
          lambda: |-
            static float t = 0;
            t += 0.15;
            for (int i = 0; i < it.size(); i++) {
              float swirl = sin(t + i * M_PI / 4) + cos(t * 0.8 + i * M_PI / 5);
              uint8_t r = (swirl + 2) * 63;
              uint8_t b = (swirl + 2) * 95;
              it[i] = ESPColor(r, 0, b);
            }
      - addressable_lambda:
          name: "Strobe Chaos"
          update_interval: 50ms
          lambda: |-
            if (rand() % 3 == 0) {
              it.all() = ESPColor(rand() % 256, rand() % 256, rand() % 256);
            } else {
              it.all() = ESPColor(0, 0, 0);
            }
      - addressable_lambda:
          name: "Heartbeat"
          update_interval: 40ms
          lambda: |-
            static float t = 0;
            t += 0.2;
            float pulse = (sin(t) * sin(t * 3)) * 255;
            if (pulse < 0) pulse = 0;
            for (int i = 0; i < it.size(); i++) {
              it[i] = ESPColor(pulse, 0, 0);
            }
      - addressable_lambda:
          name: "Galactic Pulse"
          update_interval: 90ms
          lambda: |-
            static float t = 0;
            t += 0.07;
            for (int i = 0; i < it.size(); i++) {
              float dist = fabs(i - it.size() / 2);
              float pulse = sin(t + dist * 0.5) * 127 + 127;
              it[i] = ESPColor(pulse, pulse / 2, pulse);
            }
      - addressable_lambda:
          name: "Neon Chase"
          update_interval: 85ms
          lambda: |-
            static int pos = 0;
            pos = (pos + 1) % it.size();
            it.all() = ESPColor(20, 0, 20);
            it[pos] = ESPColor(255, 0, 255);
            int tail = (pos - 1 + it.size()) % it.size();
            it[tail] = ESPColor(127, 0, 127);
      - addressable_lambda:
          name: "Ripple Echo"
          update_interval: 65ms
          lambda: |-
            static float centers[2] = {0, 8};
            it.all() = ESPColor(0, 0, 0);
            for (int c = 0; c < 2; c++) {
              centers[c] += 0.3;
              if (centers[c] > it.size()) centers[c] -= it.size();
              for (int i = 0; i < it.size(); i++) {
                float dist = fabs(i - centers[c]);
                if (dist < 3) {
                  uint8_t val = (3 - dist) * 85;
                  uint8_t r = it[i].get_red() + val;
                  uint8_t g = it[i].get_green();
                  uint8_t b = it[i].get_blue() + val;
                  it[i] = ESPColor(r > 255 ? 255 : r, g, b > 255 ? 255 : b);
                }
              }
            }
      - addressable_lambda:
          name: "Solar Flare"
          update_interval: 110ms
          lambda: |-
            static float t = 0;
            t += 0.04;
            for (int i = 0; i < it.size(); i++) {
              float flare = sin(t + i * 0.2) + (rand() % 50) / 50.0;
              uint8_t r = (flare + 1) * 127;
              uint8_t g = (flare > 0.5) ? (flare - 0.5) * 255 : 0;
              it[i] = ESPColor(r, g, 0);
            }
      - addressable_lambda:
          name: "Fractal Glow"
          update_interval: 55ms
          lambda: |-
            static float t = 0;
            t += 0.09;
            for (int i = 0; i < it.size(); i++) {
              float fractal = sin(t + i * 0.5) * cos(t * 0.3 + i * 0.7);
              uint8_t r = (fractal + 1) * 127;
              uint8_t g = (sin(t * 1.2 + i) + 1) * 127;
              it[i] = ESPColor(r, g, 0);
            }
      - addressable_lambda:
          name: "Binary Clock"
          update_interval: 1000ms
          lambda: |-
            auto time = id(esp32_time).now();
            int hour = time.hour % 12;
            int minute = time.minute / 4;
            it.all() = ESPColor(0, 0, 0);
            for (int i = 0; i < 8; i++) {
              if (hour & (1 << i)) it[i] = ESPColor(255, 0, 0);
              if (minute & (1 << i)) it[i + 8] = ESPColor(0, 255, 0);
            }
      - addressable_lambda:
          name: "Chasing Waves"
          update_interval: 75ms
          lambda: |-
            static float t = 0;
            t += 0.1;
            for (int i = 0; i < it.size(); i++) {
              float wave = sin(t + i * 0.8) + sin(t * 1.5 - i * 0.6);
              uint8_t val = (wave + 2) * 63;
              it[i] = ESPColor(val, val, 255);
            }
      - addressable_lambda:
          name: "Prism Split"
          update_interval: 60ms
          lambda: |-
            static float t = 0;
            t += 0.13;
            for (int i = 0; i < it.size(); i++) {
              float split = sin(t + i * 0.4);
              if (split > 0.33) {
                it[i] = ESPColor(255, 0, 0);
              } else if (split > -0.33) {
                it[i] = ESPColor(0, 255, 0);
              } else {
                it[i] = ESPColor(0, 0, 255);
              }
            }
      - addressable_lambda:
          name: "Glow Orbit"
          update_interval: 70ms
          lambda: |-
            static float t = 0;
            t += 0.08;
            it.all() = ESPColor(0, 0, 0);
            int pos = (int)(t * it.size()) % it.size();
            it[pos] = ESPColor(255, 255, 255);
            int glow = (pos - 1 + it.size()) % it.size();
            it[glow] = ESPColor(127, 127, 127);
            glow = (pos + 1) % it.size();
            it[glow] = ESPColor(127, 127, 127);
      - addressable_lambda:
          name: "Color Bloom"
          update_interval: 95ms
          lambda: |-
            static float t = 0;
            t += 0.06;
            for (int i = 0; i < it.size(); i++) {
              float bloom = sin(t + i * 0.5) * cos(t * 0.7);
              uint8_t r = (bloom + 1) * 127;
              uint8_t g = (bloom > 0) ? bloom * 255 : 0;
              uint8_t b = (bloom < 0) ? -bloom * 255 : 0;
              it[i] = ESPColor(r, g, b);
            }
      - addressable_lambda:
          name: "Sparkle Fade"
          update_interval: 50ms
          lambda: |-
            static uint8_t sparks[16] = {0};
            if (rand() % 10 == 0) {
              sparks[rand() % it.size()] = 255;
            }
            for (int i = 0; i < it.size(); i++) {
              sparks[i] = (sparks[i] > 10) ? sparks[i] - 10 : 0;
              it[i] = ESPColor(sparks[i], sparks[i], sparks[i]);
            }
      - addressable_lambda:
          name: "Twilight Drift"
          update_interval: 130ms
          lambda: |-
            static float t = 0;
            t += 0.02;
            for (int i = 0; i < it.size(); i++) {
              float drift = sin(t + i * 0.3) + cos(t * 0.5 + i * 0.2);
              uint8_t r = (drift + 2) * 31;
              uint8_t g = (drift + 2) * 63;
              uint8_t b = (drift + 2) * 95;
              it[i] = ESPColor(r, g, b);
            }
      - addressable_lambda:
          name: "Pulse Matrix"
          update_interval: 85ms
          lambda: |-
            static float t = 0;
            t += 0.1;
            for (int i = 0; i < it.size(); i++) {
              float pulse = sin(t + i * M_PI / 8) * sin(t * 0.8 + i * M_PI / 4);
              uint8_t val = (pulse + 1) * 127;
              it[i] = ESPColor(val, val / 2, 0);
            }

sensor:
  - platform: template
    id: next_timer
    name: "Next timer"
    update_interval: never
    disabled_by_default: true
    device_class: duration
    unit_of_measurement: s
    icon: "mdi:timer"
  - platform: adc
    id: battery_voltage
    pin: GPIO10
    name: "Battery Voltage"
    unit_of_measurement: "V"
    update_interval: 60s
    accuracy_decimals: 2
    filters:
      - multiply: 2
    on_value:
      - logger.log:
          format: "Battery voltage: %.2f V"
          args: ["x"]
      - if:
          condition: 
            lambda: return x < 0.05;
          then:
            - logger.log: "Low battery alert triggered"
            - lambda: id(low_battery_alert) = true;
            - script.execute: control_leds
          else:
            - logger.log: "Battery level normal"
            - lambda: id(low_battery_alert) = false;
            - script.execute: control_leds
  - platform: template
    id: voice_assistant_phase_sensor
    name: "Voice Assistant Phase"
    lambda: return id(voice_assistant_phase);
    update_interval: 1s
    unit_of_measurement: ""
    icon: "mdi:state-machine"

text_sensor:
  - platform: template
    id: next_timer_name
    name: "Next timer name"
    icon: "mdi:timer"
    disabled_by_default: true
  - platform: template
    id: tts_uri
    name: "TTS URI"
    disabled_by_default: true
  - platform: template
    id: last_led_trigger
    name: "Last LED Trigger"
    icon: "mdi:led-on"
    update_interval: never
  - platform: template
    id: last_response_text
    name: "Last Response Text"
    internal: true
    update_interval: never

event:
  - platform: template
    id: button_press_event
    name: "Button press"
    icon: mdi:button-pointer
    device_class: button
    event_types:
      - double_press
      - triple_press
      - long_press

script:
  - id: control_leds
    then:
      - logger.log: "Starting control_leds script execution"
      - if:
          condition:
            lambda: return id(debug_mode);
          then:
            - lambda: |-
                ESP_LOGD("control_leds", "voice_assistant_phase: %d", id(voice_assistant_phase));
                ESP_LOGD("control_leds", "improv_ble_in_progress: %d", id(improv_ble_in_progress));
                ESP_LOGD("control_leds", "init_in_progress: %d", id(init_in_progress));
                ESP_LOGD("control_leds", "wifi_connected: %d", id(wifi_id).is_connected());
                ESP_LOGD("control_leds", "api_connected: %d", id(api_id).is_connected());
                ESP_LOGD("control_leds", "user_button_state: %d", id(user_button).state);
                ESP_LOGD("control_leds", "low_battery_alert: %d", id(low_battery_alert));
                ESP_LOGD("control_leds", "timer_ringing: %d", id(timer_ringing).state);
                ESP_LOGD("control_leds", "media_player_state: %d", (int)id(external_media_player).state);
                ESP_LOGD("control_leds", "is_timer_active: %d", id(is_timer_active));
      - lambda: |-
          if (id(improv_ble_in_progress)) {
            ESP_LOGD("control_leds", "Executing: improv_ble_in_progress (Blue Ring)");
            id(control_leds_improv_ble_state).execute();
            id(last_led_trigger).publish_state("Improv BLE");
          }
          else if (id(init_in_progress)) {
            ESP_LOGD("control_leds", "Executing: init_in_progress (Blue Ring)");
            id(control_leds_init_state).execute();
            id(last_led_trigger).publish_state("Initializing");
          }
          else if (!id(wifi_id).is_connected() || !id(api_id).is_connected()) {
            ESP_LOGD("control_leds", "Executing: no_ha_connection (Blue Ring)");
            id(control_leds_no_ha_connection_state).execute();
            id(last_led_trigger).publish_state("No Connection");
          }
          else if (id(user_button).state) {
            ESP_LOGD("control_leds", "Executing: user_button_pressed (Cyan Ring)");
            id(control_leds_center_button_touched).execute();
            id(last_led_trigger).publish_state("Button Pressed");
          }
          else if (id(low_battery_alert)) {
            ESP_LOGD("control_leds", "Executing: low_battery (Red Ring)");
            id(control_leds_low_battery).execute();
            id(last_led_trigger).publish_state("Low Battery");
          }
          else if (id(timer_ringing).state) {
            ESP_LOGD("control_leds", "Executing: timer_ringing (Yellow Ring)");
            id(control_leds_timer_ringing).execute();
            id(last_led_trigger).publish_state("Timer Ringing");
          }
          else if (id(voice_assistant_phase) == 2) {
            ESP_LOGD("control_leds", "Executing: va_waiting_for_command (Pink Ring)");
            id(control_leds_voice_assistant_waiting_for_command_phase).execute();
            id(last_led_trigger).publish_state("Waiting for Command");
          }
          else if (id(voice_assistant_phase) == 3) {
            ESP_LOGD("control_leds", "Executing: va_listening (Green Ring)");
            id(control_leds_voice_assistant_listening_for_command_phase).execute();
            id(last_led_trigger).publish_state("Listening");
          }
          else if (id(voice_assistant_phase) == 4) {
            ESP_LOGD("control_leds", "Executing: va_thinking (Purple Ring)");
            id(control_leds_voice_assistant_thinking_phase).execute();
            id(last_led_trigger).publish_state("Thinking");
          }
          else if (id(voice_assistant_phase) == 5) {
            ESP_LOGD("control_leds", "Executing: va_replying (Green-Cyan Alternate)");
            id(control_leds_voice_assistant_replying_phase).execute();
            id(last_led_trigger).publish_state("Speaking");
          }
          else if (id(voice_assistant_phase) == 11) {
            ESP_LOGD("control_leds", "Executing: va_error (Red Ring)");
            id(control_leds_voice_assistant_error_phase).execute();
            id(last_led_trigger).publish_state("Error");
          }
          else if (id(voice_assistant_phase) == 10) {
            ESP_LOGD("control_leds", "Executing: va_not_ready (Orange Ring)");
            id(control_leds_voice_assistant_not_ready_phase).execute();
            id(last_led_trigger).publish_state("Not Ready");
          }
          else if (id(is_timer_active)) {
            ESP_LOGD("control_leds", "Executing: timer_ticking (Yellow Ring)");
            id(control_leds_timer_ticking).execute();
            id(last_led_trigger).publish_state("Timer Ticking");
          }
          else if (id(external_media_player).state == media_player::MediaPlayerState::MEDIA_PLAYER_STATE_PLAYING) {
            ESP_LOGD("control_leds", "Executing: media_playing (Green Ring)");
            id(control_leds_media_playing).execute();
            id(last_led_trigger).publish_state("Media Playing");
          }
          else {
            ESP_LOGD("control_leds", "Executing: idle (LED Off)");
            id(control_leds_voice_assistant_idle_phase).execute();
            id(last_led_trigger).publish_state("Idle");
          }
      - logger.log: "Finished control_leds script execution"
  - id: control_leds_improv_ble_state
    then:
      - logger.log: "Setting LED: Improv BLE state (Blue Ring)"
      - lambda: |-
          id(led_red) = 0.0; id(led_green) = 0.0; id(led_blue) = 1.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_init_state
    then:
      - logger.log: "Setting LED: Init state (Blue Ring)"
      - lambda: |-
          id(led_red) = 0.0; id(led_green) = 0.0; id(led_blue) = 1.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_no_ha_connection_state
    then:
      - logger.log: "Setting LED: No HA connection (Blue Ring)"
      - lambda: |-
          id(led_red) = 0.0; id(led_green) = 0.0; id(led_blue) = 1.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_voice_assistant_idle_phase
    then:
      - logger.log: "Setting LED: VA idle (Off)"
      - light.turn_off:
          id: led_respeaker_onboard
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - logger.log: "Setting LED: VA waiting (Pink Ring)"
      - lambda: |-
          id(led_red) = 1.0; id(led_green) = 0.2; id(led_blue) = 1.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - logger.log: "Setting LED: VA listening (Green Ring)"
      - lambda: |-
          id(led_red) = 0.0; id(led_green) = 1.0; id(led_blue) = 0.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - logger.log: "Setting LED: VA thinking (Purple Ring)"
      - lambda: |-
          id(led_red) = 0.5; id(led_green) = 0.0; id(led_blue) = 0.5;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_voice_assistant_replying_phase
    then:
      - logger.log: "Setting LED: VA replying (Green-Cyan Alternate)"
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Replying Alternate"
  - id: control_leds_voice_assistant_error_phase
    then:
      - logger.log: "Setting LED: VA error (Red Ring)"
      - lambda: |-
          id(led_red) = 1.0; id(led_green) = 0.0; id(led_blue) = 0.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - logger.log: "Setting LED: VA not ready (Orange Ring)"
      - lambda: |-
          id(led_red) = 1.0; id(led_green) = 0.5; id(led_blue) = 0.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_center_button_touched
    then:
      - logger.log: "Setting LED: Button touched (Cyan Ring)"
      - lambda: |-
          id(led_red) = 0.0; id(led_green) = 1.0; id(led_blue) = 1.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_timer_ringing
    then:
      - logger.log: "Setting LED: Timer ringing (Yellow Ring)"
      - lambda: |-
          id(led_red) = 1.0; id(led_green) = 1.0; id(led_blue) = 0.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_timer_ticking
    then:
      - logger.log: "Setting LED: Timer ticking (Yellow Ring)"
      - lambda: |-
          id(led_red) = 1.0; id(led_green) = 1.0; id(led_blue) = 0.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_media_playing
    then:
      - logger.log: "Setting LED: Media playing (Green Ring)"
      - lambda: |-
          id(led_red) = 0.0; id(led_green) = 1.0; id(led_blue) = 0.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_low_battery
    then:
      - logger.log: "Setting LED: Low battery (Red Ring)"
      - lambda: |-
          id(led_red) = 1.0; id(led_green) = 0.0; id(led_blue) = 0.0;
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Ring Chase"
  - id: control_leds_question_response_state
    then:
      - logger.log: "Setting LED: Question response (RGB Cycle)"
      - light.turn_on:
          id: led_respeaker_onboard
          effect: "Question Response"
  - id: ring_timer
    then:
      - logger.log: "Ringing timer"
      - script.execute: enable_repeat_one
      - script.execute:
          id: play_sound
          priority: true
          sound_file: !lambda return id(timer_finished_sound);
  - id: enable_repeat_one
    then:
      - logger.log: "Enabling repeat one for media player"
      - lambda: |-
          id(external_media_player)
            ->make_call()
            .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
            .set_announcement(true)
            .perform();
          id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 500);
  - id: disable_repeat
    then:
      - logger.log: "Disabling repeat for media player"
      - lambda: |-
          id(external_media_player)
            ->make_call()
            .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
            .set_announcement(true)
            .perform();
          id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);
  - id: play_sound
    parameters:
      priority: bool
      sound_file: "audio::AudioFile*"
    then:
      - logger.log:
          format: "Playing sound: priority=%d"
          args: ["priority"]
      - lambda: |-
          if (priority) {
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP)
              .set_announcement(true)
              .perform();
          }
          if ((id(external_media_player).state != media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING) || priority) {
            id(external_media_player)->play_file(sound_file, true, false);
          }
  - id: fetch_first_active_timer
    then:
      - logger.log: "Fetching first active timer"
      - lambda: |-
          const auto timers = id(va).get_timers();
          auto output_timer = timers.begin()->second;
          for (auto &iterable_timer : timers) {
            if (iterable_timer.second.is_active && iterable_timer.second.seconds_left <= output_timer.seconds_left) {
              output_timer = iterable_timer.second;
            }
          }
          id(first_active_timer) = output_timer;
  - id: check_if_timers_active
    then:
      - logger.log: "Checking if timers are active"
      - lambda: |-
          const auto timers = id(va).get_timers();
          bool output = false;
          if (timers.size() > 0) {
            for (auto &iterable_timer : timers) {
              if (iterable_timer.second.is_active) {
                output = true;
              }
            }
          }
          id(is_timer_active) = output;
  - id: activate_stop_word_if_tts_step_is_long
    then:
      - logger.log: "Activating stop word after delay"
      - delay: 1s
      - lambda: id(stop_model).enable();

i2s_audio:
  - id: i2s_output
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:
      number: GPIO9
      allow_other_uses: true
  - id: i2s_input
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:
      number: GPIO9
      allow_other_uses: true

microphone:
  - platform: nabu_microphone
    i2s_din_pin: GPIO44
    adc_type: external
    pdm: false
    sample_rate: 48000
    bits_per_sample: 32bit
    i2s_mode: secondary
    i2s_audio_id: i2s_input
    channel_0:
      id: nabu_mic_va
      amplify_shift: 0
    channel_1:
      id: nabu_mic_mww
      amplify_shift: 2

speaker:
  - platform: i2s_audio
    id: i2s_audio_speaker
    sample_rate: 48000
    i2s_mode: secondary
    i2s_dout_pin: GPIO43
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    dac_type: external
    channel: stereo
    timeout: never
    buffer_duration: 100ms
    audio_dac: aic3204_dac
  - platform: mixer
    id: mixing_speaker
    output_speaker: i2s_audio_speaker
    num_channels: 2
    source_speakers:
      - id: announcement_mixing_input
        timeout: never
      - id: media_mixing_input
        timeout: never
  - platform: resampler
    id: announcement_resampling_speaker
    output_speaker: announcement_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
  - platform: resampler
    id: media_resampling_speaker
    output_speaker: media_mixing_input
    sample_rate: 48000
    bits_per_sample: 16

media_player:
  - platform: speaker
    id: external_media_player
    name: Media Player
    internal: false
    volume_increment: 0.05
    volume_min: 0.4
    volume_max: 0.85
    announcement_pipeline:
      speaker: announcement_resampling_speaker
      format: FLAC
      num_channels: 1
      sample_rate: 48000
    media_pipeline:
      speaker: media_resampling_speaker
      format: FLAC
      num_channels: 2
      sample_rate: 48000
    on_announcement:
      - logger.log: "Media player announcement started"
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
    on_state:
      - logger.log:
          format: "Media player state changed: %d"
          args: ["(int)id(external_media_player).state"]
      - if:
          condition:
            and:
              - switch.is_off: timer_ringing
              - not: {voice_assistant.is_running:}
              - not: {media_player.is_announcing:}
          then:
            - logger.log: "Removing ducking from media player"
            - mixer_speaker.apply_ducking:
                id: media_mixing_input
                decibel_reduction: 0
                duration: 1.0s
    files:
      - id: center_button_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_press.flac
      - id: center_button_double_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_double_press.flac
      - id: center_button_triple_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_triple_press.flac
      - id: center_button_long_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_long_press.flac
      - id: factory_reset_initiated_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_initiated.mp3
      - id: factory_reset_cancelled_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_cancelled.mp3
      - id: factory_reset_confirmed_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_confirmed.mp3
      - id: mute_switch_on_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_on.flac
      - id: mute_switch_off_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_off.flac
      - id: timer_finished_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/timer_finished.flac
      - id: wake_word_triggered_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/wake_word_triggered.flac

respeaker_lite:
  id: respeaker
  reset_pin: GPIO2
  mute_state:
    internal: true
    id: mute_state
  firmware_version:
    icon: mdi:application-cog
    name: XMOS firmware version
    internal: false
    id: firmware_version
  firmware:
    url: https://github.com/ArMaTeC/SmartRespeaker/raw/refs/heads/main/firmware/respeaker_lite_i2s_dfu_firmware_48k_v1.1.0.bin
    version: "1.1.0"
    md5: 9297155d1bf3eb21a9d4db52a89ea0c6
    on_begin:
      - logger.log: "Firmware update started"
      - light.turn_on:
          brightness: 50%
          red: 0.5
          green: 0.5
          blue: 0.5
          id: led_respeaker_onboard
          effect: "Slow Pulse"
    on_end:
      - logger.log: "Firmware update completed"
      - light.turn_on:
          brightness: 50%
          red: 0
          green: 1
          blue: 0
          id: led_respeaker_onboard
          effect: "Fast Pulse"
      - delay: 3s
      - light.turn_off: led_respeaker_onboard
    on_error:
      - logger.log: "Firmware update failed"
      - light.turn_on:
          brightness: 50%
          red: 1
          green: 0
          blue: 0
          id: led_respeaker_onboard
          effect: "Fast Pulse"
      - delay: 3s
      - light.turn_off: led_respeaker_onboard

external_components:
  - source:
      type: git
      url: https://github.com/ArMaTeC/SmartRespeaker
      ref: main
    components: [micro_wake_word, microphone, voice_assistant, nabu_microphone, respeaker_lite]
    refresh: 0s

audio_dac:
  - platform: aic3204
    id: aic3204_dac
    i2c_id: internal_i2c

micro_wake_word:
  id: mww
  models:
    - model: https://github.com/kahrendt/microWakeWord/releases/download/okay_nabu_20241226.3/okay_nabu.json
      id: okay_nabu
      internal: true
      probability_cutoff: 0.75
    - model: https://github.com/kahrendt/microWakeWord/releases/download/stop/stop.json
      id: stop_model
      internal: true
      probability_cutoff: 0.75
  vad:
  microphone: nabu_mic_mww
  on_wake_word_detected:
    - logger.log:
        format: "Wake word detected: %s"
        args: ["wake_word.c_str()"]
    - if:
        condition: {switch.is_off: mic_mute_switch}
        then:
          - if:
              condition: {switch.is_on: timer_ringing}
              then: 
                - logger.log: "Stopping timer ringing due to wake word"
                - switch.turn_off: timer_ringing
              else:
                - if:
                    condition: {media_player.is_announcing:}
                    then: 
                      - logger.log: "Stopping announcement due to wake word"
                      - media_player.stop: {announcement: true}
                    else:
                      - if:
                          condition:
                            lambda: return wake_word == "stop";
                          then:
                            - logger.log: "Stop wake word detected - Stopping VA"
                            - voice_assistant.stop:
                          else:
                            - logger.log: "Starting VA due to wake word"
                            - if:
                                condition: {switch.is_on: wake_sound}
                                then:
                                  - script.execute:
                                      id: play_sound
                                      priority: true
                                      sound_file: !lambda return id(wake_word_triggered_sound);
                                  - delay: 300ms
                            - voice_assistant.start:
                                silence_detection: True
                                wake_word: !lambda return wake_word;

voice_assistant:
  id: va
  microphone: nabu_mic_va
  media_player: external_media_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 0
  auto_gain: 10 dbfs
  volume_multiplier: 2
  on_client_connected:
    - logger.log: "VA client connected"
    - if:
        condition:
          and:
            - lambda: return id(init_in_progress);
            - switch.is_on: mic_mute_switch
        then: 
          - logger.log: "Unmuting mic on client connect during init"
          - switch.turn_off: mic_mute_switch
    - lambda: id(init_in_progress) = false;
    - micro_wake_word.start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_client_disconnected:
    - logger.log: "VA client disconnected"
    - voice_assistant.stop:
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: control_leds
  on_error:
    - logger.log:
        format: "VA error: code=%s, message=%s"
        args: ["code.c_str()", "message.c_str()"]
    - if:
        condition:
          and:
            - lambda: return !id(init_in_progress);
            - lambda: return code != "duplicate_wake_up_detected";
        then:
          - if:
              condition:
                and:
                  - lambda: 'return code == "stt-no-text-recognized";'
                  - switch.is_on: is_question_response_switch
              then:
                - logger.log: "STT failed after question, retrying"
                - voice_assistant.stop:
                - micro_wake_word.stop:
                - delay: 100ms
                - micro_wake_word.start:
                - delay: 500ms
                - voice_assistant.start:
                    silence_detection: True
                - delay: 1s
                - if:
                    condition:
                      not:
                        voice_assistant.is_running:
                    then:
                      - logger.log: "Retry failed, resetting to idle"
                      - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
                      - script.execute: control_leds
              else:
                - logger.log: "Unhandled error, resetting to idle"
                - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};
                - script.execute: control_leds
                - voice_assistant.stop:
                - micro_wake_word.stop:
                - delay: 100ms
                - micro_wake_word.start:
                - delay: 500ms
                - voice_assistant.start:
                    silence_detection: True
                - delay: 1s
                - if:
                    condition:
                      not:
                        voice_assistant.is_running:
                    then:
                      - logger.log: "VA failed to recover, resetting to idle"
                      - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
                      - script.execute: control_leds
  on_start:
    - logger.log: "VA started"
    - mixer_speaker.apply_ducking:
        id: media_mixing_input
        decibel_reduction: 20
        duration: 0.0s
  on_listening:
    - logger.log: "VA listening"
    - lambda: id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
    - script.execute: control_leds
    - logger.log: "VA successfully restarted and streaming"
  on_stt_vad_start:
    - logger.log: "VA STT VAD started"
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_end:
    - logger.log: "VA STT VAD ended"
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: control_leds
  on_tts_start:
    - logger.log: "VA TTS started"
    - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
    - script.execute: control_leds
    - script.execute: activate_stop_word_if_tts_step_is_long
    - text_sensor.template.publish:
        id: last_response_text
        state: !lambda 'return x;'
  on_tts_end:
    - logger.log: "VA TTS ended"
    - text_sensor.template.publish:
        id: tts_uri
        state: !lambda 'return x;'
    - lambda: |-
        ESP_LOGD("voice_assistant", "TTS ended. Last response: '%s'", id(last_response_text).state.c_str());
        ESP_LOGD("voice_assistant", "Checking if last char is '?': %d", id(last_response_text).state.back() == '?');
        ESP_LOGD("voice_assistant", "Media player state: %d", (int)id(external_media_player).state);
    - if:
        condition:
          lambda: 'return !id(last_response_text).state.empty() && id(last_response_text).state.back() == ''?'';'
        then:
          - logger.log: "Response ends with '?'. Waiting for TTS to finish"
          - switch.turn_on: is_question_response_switch
          - script.execute: control_leds_question_response_state
          - delay: 2s
          - wait_until:
              condition:
                not:
                  media_player.is_announcing:
              timeout: 10s
          - logger.log: "TTS playback finished"
          - if:
              condition: {switch.is_on: mic_mute_switch}
              then:
                - logger.log: "Unmuting microphone for response"
                - switch.turn_off: mic_mute_switch
          - if:
              condition: {switch.is_on: wake_sound}
              then:
                - script.execute:
                    id: play_sound
                    priority: true
                    sound_file: !lambda return id(wake_word_triggered_sound);
                - delay: 500ms
          - voice_assistant.stop:
          - delay: 500ms
          - micro_wake_word.stop:
          - delay: 100ms
          - micro_wake_word.start:
          - delay: 500ms
          - lambda: |-
              id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
              ESP_LOGD("voice_assistant", "Restarting VA with silence detection");
          - voice_assistant.start:
              silence_detection: True
          - logger.log: "VA restarted for question response"
          - script.execute: control_leds
          - delay: 1s
          - if:
              condition:
                not:
                  voice_assistant.is_running:
              then:
                - logger.log: "VA restart failed, forcing recovery"
                - voice_assistant.stop:
                - micro_wake_word.stop:
                - delay: 100ms
                - micro_wake_word.start:
                - delay: 500ms
                - voice_assistant.start:
                    silence_detection: True
                - delay: 1s
                - if:
                    condition:
                      not:
                        voice_assistant.is_running:
                    then:
                      - logger.log: "VA recovery failed, resetting to idle"
                      - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
                      - script.execute: control_leds
        else:
          - logger.log: "Response does not end with '?'. Not restarting"
          - switch.turn_off: is_question_response_switch
          - if:
              condition:
                lambda: 'return id(voice_assistant_phase) == ${voice_assist_replying_phase_id};'
              then:
                - logger.log: "Resetting to idle after non-question response"
                - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
                - script.execute: control_leds
  on_end:
    - logger.log: "VA ended"
    - delay: 2s
    - wait_until:
        condition:
          not:
            voice_assistant.is_running:
    - mixer_speaker.apply_ducking:
        id: media_mixing_input
        decibel_reduction: 0
        duration: 1s
    - script.stop: activate_stop_word_if_tts_step_is_long
    - if:
        condition:
          switch.is_off:
            id: timer_ringing
        then:
          - logger.log: "Disabling stop model"
          - lambda: id(stop_model).disable();
    - if:
        condition:
          lambda: 'return id(voice_assistant_phase) == ${voice_assist_error_phase_id};'
        then:
          - delay: 1s
    - if:
        condition:
          lambda: 'return id(voice_assistant_phase) != ${voice_assist_waiting_for_command_phase_id} && !id(is_question_response_switch).state;'
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
          - script.execute: control_leds
  on_timer_finished:
    - logger.log: "Timer finished"
    - switch.turn_on: timer_ringing
    - lambda: |
        id(next_timer).publish_state(-1);
        id(next_timer_name).publish_state("-");
  on_timer_started:
    - logger.log: "Timer started"
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_cancelled:
    - logger.log: "Timer cancelled"
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_updated:
    - logger.log: "Timer updated"
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_tick:
    - logger.log: "Timer tick"
    - script.execute: control_leds
    - lambda: |
        int seconds_left = id(first_active_timer).seconds_left;
        if (std::abs(seconds_left) % 5 == 0) {
          id(next_timer).publish_state(seconds_left);
        }

button:
  - platform: factory_reset
    id: factory_reset_button
    name: "Factory Reset"
    entity_category: diagnostic
    internal: true
  - platform: restart
    id: restart_button
    name: "Restart"
    entity_category: config
    disabled_by_default: true
    icon: "mdi:restart"

debug:
  update_interval: 5s
